---
title: "高级特性"
weight: 10
bookhidden: false
---

# 高级特性

Python 提供了许多高级特性，如生成器、迭代器、推导式等，这些特性可以让代码更简洁、高效。

## 迭代器和可迭代对象

### 可迭代对象（Iterable）

可迭代对象是可以返回迭代器的对象，实现了 `__iter__()` 方法。

```python
# 常见的可迭代对象
my_list = [1, 2, 3]      # 列表
my_string = "hello"      # 字符串
my_dict = {"a": 1}       # 字典
my_set = {1, 2, 3}       # 集合
my_tuple = (1, 2, 3)     # 元组

# 检查是否为可迭代对象
from collections.abc import Iterable
print(isinstance(my_list, Iterable))  # True

# 使用iter()获取迭代器
iterator = iter(my_list)
```

### 迭代器（Iterator）

迭代器是实现了 `__iter__()` 和 `__next__()` 方法的对象。

```python
# 手动迭代
my_list = [1, 2, 3]
iterator = iter(my_list)

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# print(next(iterator))  # StopIteration异常

# 自定义迭代器
class CountDown:
    def __init__(self, start):
        self.current = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        self.current -= 1
        return self.current + 1

# 使用
for num in CountDown(5):
    print(num)  # 5, 4, 3, 2, 1
```

## 生成器（Generator）（重点难点）

生成器是一种特殊的迭代器，使用 `yield` 关键字创建。

### 生成器函数

```python
# 基本生成器函数
def countdown(n):
    while n > 0:
        yield n
        n -= 1

# 使用生成器
for num in countdown(5):
    print(num)  # 5, 4, 3, 2, 1

# 手动调用
gen = countdown(3)
print(next(gen))  # 3
print(next(gen))  # 2
print(next(gen))  # 1
```

### 生成器的优势

**内存效率**：生成器按需生成值，不需要一次性存储所有值。

```python
# 普通函数（占用大量内存）
def squares_list(n):
    result = []
    for i in range(n):
        result.append(i ** 2)
    return result

# 生成器（内存效率高）
def squares_generator(n):
    for i in range(n):
        yield i ** 2

# 比较
list_squares = squares_list(1000000)  # 占用大量内存
gen_squares = squares_generator(1000000)  # 几乎不占用内存
```

### 生成器表达式

生成器表达式类似于列表推导式，但返回生成器。

```python
# 列表推导式（返回列表）
squares_list = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]

# 生成器表达式（返回生成器）
squares_gen = (x**2 for x in range(5))  # <generator object>
print(list(squares_gen))  # [0, 1, 4, 9, 16]

# 内存效率对比
import sys
list_size = sys.getsizeof([x**2 for x in range(1000)])
gen_size = sys.getsizeof((x**2 for x in range(1000)))
print(f"列表大小: {list_size}, 生成器大小: {gen_size}")
```

### 生成器的实际应用

```python
# 读取大文件
def read_large_file(filename):
    with open(filename, "r", encoding="utf-8") as file:
        for line in file:
            yield line.strip()

# 使用
for line in read_large_file("large_file.txt"):
    process(line)

# 无限序列
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用（需要限制）
fib = fibonacci()
for _ in range(10):
    print(next(fib))
```

## 推导式

### 列表推导式

```python
# 基本语法：[表达式 for 变量 in 可迭代对象]
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]

# 带条件
evens = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]

# 嵌套循环
matrix = [[i*j for j in range(3)] for i in range(3)]
# [[0, 0, 0], [0, 1, 2], [0, 2, 4]]

# 条件表达式
result = [x if x > 0 else 0 for x in range(-3, 4)]
# [0, 0, 0, 0, 1, 2, 3]
```

### 字典推导式

```python
# 基本语法：{键表达式: 值表达式 for 变量 in 可迭代对象}
squares_dict = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 带条件
evens_dict = {x: x**2 for x in range(10) if x % 2 == 0}

# 从列表创建字典
names = ["Alice", "Bob", "Charlie"]
name_lengths = {name: len(name) for name in names}
# {'Alice': 5, 'Bob': 3, 'Charlie': 7}
```

### 集合推导式

```python
# 基本语法：{表达式 for 变量 in 可迭代对象}
squares_set = {x**2 for x in range(5)}  # {0, 1, 4, 9, 16}

# 带条件
evens_set = {x for x in range(10) if x % 2 == 0}  # {0, 2, 4, 6, 8}
```

### 元组推导式？

Python 没有元组推导式，但可以使用生成器表达式：

```python
# 生成器表达式（类似元组推导式）
squares_gen = (x**2 for x in range(5))
squares_tuple = tuple(squares_gen)  # (0, 1, 4, 9, 16)
```

## 装饰器深入（重点难点）

### 带参数的函数的装饰器

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("函数执行前")
        result = func(*args, **kwargs)
        print("函数执行后")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

result = add(2, 3)
# 输出:
# 函数执行前
# 函数执行后
# result = 5
```

### 带参数的装饰器

```python
def repeat(times):
    """带参数的装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Hello!")

say_hello()
# 输出:
# Hello!
# Hello!
# Hello!
```

### 多个装饰器

```python
def bold(func):
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold
@italic
def hello():
    return "Hello"

print(hello())  # <b><i>Hello</i></b>
```

### 类装饰器

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # 函数被调用了 1 次
say_hello()  # 函数被调用了 2 次
```

### 保留函数元数据的装饰器

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """包装函数"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """问候函数"""
    print("Hello!")

print(say_hello.__name__)  # say_hello（而不是wrapper）
print(say_hello.__doc__)   # 问候函数（而不是"包装函数"）
```

## 上下文管理器深入

### 使用 contextlib

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("进入上下文")
    try:
        yield "资源"
    finally:
        print("退出上下文")

# 使用
with my_context() as resource:
    print(f"使用 {resource}")
```

### 上下文管理器协议

```python
class MyContextManager:
    def __enter__(self):
        print("进入上下文")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出上下文")
        # 返回False表示不抑制异常
        # 返回True表示抑制异常
        return False

# 使用
with MyContextManager() as cm:
    print("在上下文中")
```

## 描述符（Descriptor）

描述符是实现了 `__get__`、`__set__` 或 `__delete__` 方法的对象。

```python
class Descriptor:
    def __init__(self, name):
        self.name = name
    
    def __get__(self, obj, objtype=None):
        print(f"获取 {self.name}")
        return obj.__dict__.get(self.name)
    
    def __set__(self, obj, value):
        print(f"设置 {self.name} = {value}")
        obj.__dict__[self.name] = value

class MyClass:
    x = Descriptor("x")
    
    def __init__(self, x):
        self.x = x

obj = MyClass(10)
print(obj.x)  # 获取 x, 然后输出 10
obj.x = 20    # 设置 x = 20
```

## 属性访问魔法方法

```python
class MyClass:
    def __init__(self):
        self._value = 0
    
    def __getattribute__(self, name):
        """访问任何属性时调用"""
        print(f"访问属性: {name}")
        return super().__getattribute__(name)
    
    def __getattr__(self, name):
        """访问不存在的属性时调用"""
        print(f"属性 {name} 不存在")
        return None
    
    def __setattr__(self, name, value):
        """设置属性时调用"""
        print(f"设置属性 {name} = {value}")
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        """删除属性时调用"""
        print(f"删除属性: {name}")
        super().__delattr__(name)
```

## 元类（Metaclass）

元类是创建类的类，是 Python 的高级特性。

```python
class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        # 在创建类之前可以修改类
        attrs['created_by'] = 'MyMeta'
        return super().__new__(cls, name, bases, attrs)

class MyClass(metaclass=MyMeta):
    pass

print(MyClass.created_by)  # MyMeta
```

## 协程和 async/await

```python
import asyncio

async def fetch_data():
    """异步函数"""
    await asyncio.sleep(1)
    return "数据"

async def main():
    result = await fetch_data()
    print(result)

# 运行
asyncio.run(main())
```

## 最佳实践

1. **优先使用生成器处理大序列**
2. **推导式要简洁，复杂逻辑用循环**
3. **合理使用装饰器，避免过度装饰**
4. **理解上下文管理器的工作原理**
5. **谨慎使用高级特性，保持代码可读性**

## 下一步

掌握了高级特性后，可以学习：

1. [常用内置函数](11-常用内置函数.md) - 学习常用的内置函数，提高编程效率
